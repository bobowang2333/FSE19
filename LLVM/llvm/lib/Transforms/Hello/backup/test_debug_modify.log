Computing live-in reg-units in ABI blocks.
0B	BB#0 DIL#0 SIL#0
Created 2 new intervals.
********** INTERVALS **********
DIL [0B,32r:0)  0@0B-phi
SIL [0B,16r:0)  0@0B-phi
%vreg0 [32r,48r:0)  0@32r
%vreg1 [16r,80r:0)  0@16r
%vreg2 [80r,96r:0)[96r,112r:1)  0@80r 1@96r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function add: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0, %ESI in %vreg1

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI %ESI
16B		%vreg1<def> = COPY %ESI; GR32:%vreg1
32B		%vreg0<def> = COPY %EDI; GR32:%vreg0
48B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%x.addr] GR32:%vreg0
64B		MOV32mr <fi#1>, 1, %noreg, 0, %noreg, %vreg1; mem:ST4[%y.addr] GR32:%vreg1
80B		%vreg2<def> = COPY %vreg1; GR32:%vreg2,%vreg1
96B		%vreg2<def,tied1> = ADD32rm %vreg2<tied0>, <fi#0>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:LD4[%x.addr] GR32:%vreg2
112B		%EAX<def> = COPY %vreg2; GR32:%vreg2
128B		RETQ %EAX<kill>

# End machine code for function add.

********** SIMPLE REGISTER COALESCING **********
********** Function: add
********** JOINING INTERVALS ***********
entry:
16B	%vreg1<def> = COPY %ESI; GR32:%vreg1
	Considering merging %vreg1 with %ESI
	Can only merge into reserved registers.
32B	%vreg0<def> = COPY %EDI; GR32:%vreg0
	Considering merging %vreg0 with %EDI
	Can only merge into reserved registers.
112B	%EAX<def> = COPY %vreg2; GR32:%vreg2
	Considering merging %vreg2 with %EAX
	Can only merge into reserved registers.
80B	%vreg2<def> = COPY %vreg1; GR32:%vreg2,%vreg1
	Considering merging to GR32 with %vreg1 in %vreg2
		RHS = %vreg1 [16r,80r:0)  0@16r
		LHS = %vreg2 [80r,96r:0)[96r,112r:1)  0@80r 1@96r
		merge %vreg2:0@80r into %vreg1:0@16r --> @16r
		erased:	80r	%vreg2<def> = COPY %vreg1; GR32:%vreg2,%vreg1
AllocationOrder(GR32) = [ %EAX %ECX %EDX %ESI %EDI %R8D %R9D %R10D %R11D %EBX %R14D %R15D %R12D %R13D ]
		updated: 16B	%vreg2<def> = COPY %ESI; GR32:%vreg2
		updated: 64B	MOV32mr <fi#1>, 1, %noreg, 0, %noreg, %vreg2; mem:ST4[%y.addr] GR32:%vreg2
	Success: %vreg1 -> %vreg2
	Result = %vreg2 [16r,96r:0)[96r,112r:1)  0@16r 1@96r
Trying to inflate 0 regs.
********** INTERVALS **********
DIL [0B,32r:0)  0@0B-phi
SIL [0B,16r:0)  0@0B-phi
%vreg0 [32r,48r:0)  0@32r
%vreg2 [16r,96r:0)[96r,112r:1)  0@16r 1@96r
RegMasks:
********** MACHINEINSTRS **********
# Machine code for function add: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]
  fi#1: size=4, align=4, at location [SP+8]
Function Live Ins: %EDI in %vreg0, %ESI in %vreg1

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI %ESI
16B		%vreg2<def> = COPY %ESI; GR32:%vreg2
32B		%vreg0<def> = COPY %EDI; GR32:%vreg0
48B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0; mem:ST4[%x.addr] GR32:%vreg0
64B		MOV32mr <fi#1>, 1, %noreg, 0, %noreg, %vreg2; mem:ST4[%y.addr] GR32:%vreg2
96B		%vreg2<def,tied1> = ADD32rm %vreg2<tied0>, <fi#0>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:LD4[%x.addr] GR32:%vreg2
112B		%EAX<def> = COPY %vreg2; GR32:%vreg2
128B		RETQ %EAX<kill>

# End machine code for function add.

AllocationOrder(GR32) = [ %EAX %ECX %EDX %ESI %EDI %R8D %R9D %R10D %R11D %EBX %R14D %R15D %R12D %R13D ]
AllocationOrder(GR16) = [ %AX %CX %DX %SI %DI %R8W %R9W %R10W %R11W %BX %R14W %R15W %R12W %R13W ]
AllocationOrder(GR8) = [ %AL %CL %DL %SIL %DIL %R8B %R9B %R10B %R11B %BL %R14B %R15B %R12B %R13B ]
********** BASIC REGISTER ALLOCATION **********
********** Function: add

selectOrSplit GR32:%vreg0 [32r,48r:0)  0@32r w=inf
AllocationOrder(GR32) = [ %EAX %ECX %EDX %ESI %EDI %R8D %R9D %R10D %R11D %EBX %R14D %R15D %R12D %R13D ]
hints: %EDI
assigning %vreg0 to %EDI: DIL [32r,48r:0)  0@32r

selectOrSplit GR32:%vreg2 [16r,96r:0)[96r,112r:1)  0@16r 1@96r w=1.018145e-02
hints: %ESI
assigning %vreg2 to %ESI: SIL [16r,96r:0)[96r,112r:1)  0@16r 1@96r
Post alloc VirtRegMap:
********** REGISTER MAP **********
[%vreg0 -> %EDI] GR32
[%vreg2 -> %ESI] GR32


********** REWRITE VIRTUAL REGISTERS **********
********** Function: add
********** REGISTER MAP **********
[%vreg0 -> %EDI] GR32
[%vreg2 -> %ESI] GR32

0B	BB#0: derived from LLVM BB %entry
	    Live Ins: %EDI %ESI
16B		%vreg2<def> = COPY %ESI; GR32:%vreg2
32B		%vreg0<def> = COPY %EDI; GR32:%vreg0
48B		MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %vreg0<kill>; mem:ST4[%x.addr] GR32:%vreg0
64B		MOV32mr <fi#1>, 1, %noreg, 0, %noreg, %vreg2; mem:ST4[%y.addr] GR32:%vreg2
96B		%vreg2<def,tied1> = ADD32rm %vreg2<kill,tied0>, <fi#0>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:LD4[%x.addr] GR32:%vreg2
112B		%EAX<def> = COPY %vreg2<kill>; GR32:%vreg2
128B		RETQ %EAX<kill>
> %ESI<def> = COPY %ESI
Deleting identity copy.
> %EDI<def> = COPY %EDI
Deleting identity copy.
> MOV32mr <fi#0>, 1, %noreg, 0, %noreg, %EDI<kill>; mem:ST4[%x.addr]
> MOV32mr <fi#1>, 1, %noreg, 0, %noreg, %ESI; mem:ST4[%y.addr]
> %ESI<def,tied1> = ADD32rm %ESI<kill,tied0>, <fi#0>, 1, %noreg, 0, %noreg, %EFLAGS<imp-def,dead>; mem:LD4[%x.addr]
> %EAX<def> = COPY %ESI<kill>
> RETQ %EAX<kill>
Computing live-in reg-units in ABI blocks.
Created 0 new intervals.
********** INTERVALS **********
%vreg0 [48r,80r:0)  0@48r
%vreg1 [64r,96r:0)  0@64r
%vreg2 [144r,240r:0)  0@144r
%vreg3 [176r,224r:0)  0@176r
%vreg4 [192r,304r:0)  0@192r
%vreg5 [208r,256r:0)  0@208r
RegMasks: 112r 272r
********** MACHINEINSTRS **********
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	BB#0: derived from LLVM BB %entry
16B		MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
48B		%vreg0<def> = MOV32ri 3; GR32:%vreg0
64B		%vreg1<def> = MOV32ri 4; GR32:%vreg1
80B		%EDI<def> = COPY %vreg0; GR32:%vreg0
96B		%ESI<def> = COPY %vreg1; GR32:%vreg1
112B		CALL64pcrel32 <ga:@add>, <regmask>, %RSP<imp-use>, %EDI<imp-use,kill>, %ESI<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def>
128B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
144B		%vreg2<def> = COPY %EAX<kill>; GR32:%vreg2
160B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
176B		%vreg3<def> = LEA64r %RIP, 1, %noreg, <ga:@.str>, %noreg; GR64:%vreg3
192B		%vreg4<def> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg4
208B		%vreg5<def> = COPY %vreg4:sub_8bit; GR8:%vreg5 GR32:%vreg4
224B		%RDI<def> = COPY %vreg3; GR64:%vreg3
240B		%ESI<def> = COPY %vreg2; GR32:%vreg2
256B		%AL<def> = COPY %vreg5; GR8:%vreg5
272B		CALL64pcrel32 <ga:@printf>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>
288B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
304B		%EAX<def> = COPY %vreg4; GR32:%vreg4
320B		RETQ %EAX<kill>

# End machine code for function main.

********** SIMPLE REGISTER COALESCING **********
********** Function: main
********** JOINING INTERVALS ***********
entry:
80B	%EDI<def> = COPY %vreg0; GR32:%vreg0
	Considering merging %vreg0 with %EDI
	Can only merge into reserved registers.
Remat: %EDI<def> = MOV32ri 3
Shrink: %vreg0 [48r,80r:0)  0@48r
All defs dead: 48r	%vreg0<def,dead> = MOV32ri 3; GR32:%vreg0
Shrunk: %vreg0 [48r,48d:0)  0@48r
Deleting dead def 48r	%vreg0<def,dead> = MOV32ri 3; GR32:%vreg0
96B	%ESI<def> = COPY %vreg1; GR32:%vreg1
	Considering merging %vreg1 with %ESI
	Can only merge into reserved registers.
Remat: %ESI<def> = MOV32ri 4
Shrink: %vreg1 [64r,96r:0)  0@64r
All defs dead: 64r	%vreg1<def,dead> = MOV32ri 4; GR32:%vreg1
Shrunk: %vreg1 [64r,64d:0)  0@64r
Deleting dead def 64r	%vreg1<def,dead> = MOV32ri 4; GR32:%vreg1
144B	%vreg2<def> = COPY %EAX<kill>; GR32:%vreg2
	Considering merging %vreg2 with %EAX
	Can only merge into reserved registers.
224B	%RDI<def> = COPY %vreg3; GR64:%vreg3
	Considering merging %vreg3 with %RDI
	Can only merge into reserved registers.
240B	%ESI<def> = COPY %vreg2; GR32:%vreg2
	Considering merging %vreg2 with %ESI
	Can only merge into reserved registers.
256B	%AL<def> = COPY %vreg5; GR8:%vreg5
	Considering merging %vreg5 with %AL
	Can only merge into reserved registers.
304B	%EAX<def> = COPY %vreg4; GR32:%vreg4
	Considering merging %vreg4 with %EAX
	Can only merge into reserved registers.
Remat: %EAX<def> = MOV32r0 %EFLAGS<imp-def,dead>
Shrink: %vreg4 [192r,304r:0)  0@192r
Shrunk: %vreg4 [192r,208r:0)  0@192r
208B	%vreg5<def> = COPY %vreg4:sub_8bit; GR8:%vreg5 GR32:%vreg4
	Considering merging to GR32 with %vreg5 in %vreg4:sub_8bit
		RHS = %vreg5 [208r,256r:0)  0@208r
		LHS = %vreg4 [192r,208r:0)  0@192r
		merge %vreg5:0@208r into %vreg4:0@192r --> @192r
		erased:	208r	%vreg5<def> = COPY %vreg4:sub_8bit; GR8:%vreg5 GR32:%vreg4
		updated: 256B	%AL<def> = COPY %vreg4:sub_8bit; GR32:%vreg4
	Success: %vreg5:sub_8bit -> %vreg4
	Result = %vreg4 [192r,256r:0)  0@192r
240B	%ESI<def> = COPY %vreg2; GR32:%vreg2
	Considering merging %vreg2 with %ESI
	Can only merge into reserved registers.
256B	%AL<def> = COPY %vreg4:sub_8bit; GR32:%vreg4
	Considering merging %vreg4 with %EAX
	Can only merge into reserved registers.
Remat: %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
Shrink: %vreg4 [192r,256r:0)  0@192r
All defs dead: 192r	%vreg4<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg4
Shrunk: %vreg4 [192r,192d:0)  0@192r
Deleting dead def 192r	%vreg4<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>; GR32:%vreg4
240B	%ESI<def> = COPY %vreg2; GR32:%vreg2
	Considering merging %vreg2 with %ESI
	Can only merge into reserved registers.
Trying to inflate 0 regs.
********** INTERVALS **********
%vreg2 [144r,240r:0)  0@144r
%vreg3 [176r,224r:0)  0@176r
RegMasks: 112r 272r
********** MACHINEINSTRS **********
# Machine code for function main: Post SSA
Frame Objects:
  fi#0: size=4, align=4, at location [SP+8]

0B	BB#0: derived from LLVM BB %entry
16B		MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
80B		%EDI<def> = MOV32ri 3
96B		%ESI<def> = MOV32ri 4
112B		CALL64pcrel32 <ga:@add>, <regmask>, %RSP<imp-use>, %EDI<imp-use,kill>, %ESI<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def>
128B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
144B		%vreg2<def> = COPY %EAX<kill>; GR32:%vreg2
160B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
176B		%vreg3<def> = LEA64r %RIP, 1, %noreg, <ga:@.str>, %noreg; GR64:%vreg3
224B		%RDI<def> = COPY %vreg3; GR64:%vreg3
240B		%ESI<def> = COPY %vreg2; GR32:%vreg2
256B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
272B		CALL64pcrel32 <ga:@printf>, <regmask>, %RSP<imp-use>, %RDI<imp-use,kill>, %ESI<imp-use,kill>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>
288B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
304B		%EAX<def> = MOV32r0 %EFLAGS<imp-def,dead>
320B		RETQ %EAX<kill>

# End machine code for function main.

handleMove 240B -> 264B: %ESI<def> = COPY %vreg2; GR32:%vreg2
     SIL:	[96r,112r:0)[264r,272r:1)  0@96r 1@264r
        -->	[96r,112r:0)[264r,272r:1)  0@96r 1@264r
     %vreg2:	[144r,240r:0)  0@144r
        -->	[144r,264r:0)  0@144r
handleMove 224B -> 260B: %RDI<def> = COPY %vreg3; GR64:%vreg3
     DIL:	[80r,112r:0)[260r,272r:1)  0@80r 1@260r
        -->	[80r,112r:0)[260r,272r:1)  0@80r 1@260r
     %vreg3:	[176r,224r:0)  0@176r
        -->	[176r,260r:0)  0@176r
********** BASIC REGISTER ALLOCATION **********
********** Function: main

selectOrSplit GR32:%vreg2 [144r,264r:0)  0@144r w=3.884615e-03
hints: %EAX
assigning %vreg2 to %ECX: CH [144r,264r:0)  0@144r CL [144r,264r:0)  0@144r

selectOrSplit GR64:%vreg3 [176r,260r:0)  0@176r w=2.086777e-03
AllocationOrder(GR64) = [ %RAX %RCX %RDX %RSI %RDI %R8 %R9 %R10 %R11 %RBX %R14 %R15 %R12 %R13 ]
hints: %RDI
assigning %vreg3 to %RDI: DIL [176r,260r:0)  0@176r
Post alloc VirtRegMap:
********** REGISTER MAP **********
[%vreg2 -> %ECX] GR32
[%vreg3 -> %RDI] GR64


********** REWRITE VIRTUAL REGISTERS **********
********** Function: main
********** REGISTER MAP **********
[%vreg2 -> %ECX] GR32
[%vreg3 -> %RDI] GR64

0B	BB#0: derived from LLVM BB %entry
16B		MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
32B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
80B		%EDI<def> = MOV32ri 3
96B		%ESI<def> = MOV32ri 4
112B		CALL64pcrel32 <ga:@add>, <regmask>, %RSP<imp-use>, %EDI<imp-use>, %ESI<imp-use>, %RSP<imp-def>, %EAX<imp-def>
128B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
144B		%vreg2<def> = COPY %EAX; GR32:%vreg2
160B		ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
176B		%vreg3<def> = LEA64r %RIP, 1, %noreg, <ga:@.str>, %noreg; GR64:%vreg3
256B		%EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
260B		%RDI<def> = COPY %vreg3<kill>; GR64:%vreg3
264B		%ESI<def> = COPY %vreg2<kill>; GR32:%vreg2
272B		CALL64pcrel32 <ga:@printf>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>
288B		ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
304B		%EAX<def> = MOV32r0 %EFLAGS<imp-def,dead>
320B		RETQ %EAX
> MOV32mi <fi#0>, 1, %noreg, 0, %noreg, 0; mem:ST4[%retval]
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %EDI<def> = MOV32ri 3
> %ESI<def> = MOV32ri 4
> CALL64pcrel32 <ga:@add>, <regmask>, %RSP<imp-use>, %EDI<imp-use>, %ESI<imp-use>, %RSP<imp-def>, %EAX<imp-def>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %ECX<def> = COPY %EAX
> ADJCALLSTACKDOWN64 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %RDI<def> = LEA64r %RIP, 1, %noreg, <ga:@.str>, %noreg
> %EAX<def,dead> = MOV32r0 %EFLAGS<imp-def,dead>, %AL<imp-def>
> %RDI<def> = COPY %RDI<kill>
Deleting identity copy.
> %ESI<def> = COPY %ECX<kill>
> CALL64pcrel32 <ga:@printf>, <regmask>, %RSP<imp-use>, %RDI<imp-use>, %ESI<imp-use>, %AL<imp-use,kill>, %RSP<imp-def>, %EAX<imp-def,dead>
> ADJCALLSTACKUP64 0, 0, %RSP<imp-def>, %EFLAGS<imp-def,dead>, %RSP<imp-use>
> %EAX<def> = MOV32r0 %EFLAGS<imp-def,dead>
> RETQ %EAX
